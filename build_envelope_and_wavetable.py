import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import CubicSpline


def interpolate(y_period, overlapCorrectionFactor = 1.0, debug=False, newLength=256):
    x = np.arange(len(y_period))*newLength/len(y_period)*overlapCorrectionFactor
    x = [*x, newLength]
    y = [*y_period, y_period[0]]
    cs = CubicSpline(x, y)
    xnew = np.arange(newLength)
    ynew = cs(xnew)
    if debug: #debug
        plt.scatter(x, y, label='alt')
        plt.plot(x, y, label='alt')
        plt.scatter(xnew, ynew, label='neu')
        
        graph_x = np.arange(0, newLength-1, 0.2)
        plt.plot(graph_x, cs(graph_x), label='interpolation')
        plt.legend()
        plt.grid()
        plt.show()
    return ynew
def normalize(y, bit=8):
    max_val = pow(2, bit-1) -1
    min_val = -pow(2, bit-1)
    print(min_val, max_val)
    print(min_val/np.min(y), max_val/np.max(y))
    factor = min(min_val/np.min(y), max_val/np.max(y))
    return factor * y
    

Epiano_mda_autopan_raw = 6.620*128*np.array([0.00422, 0.01251, 0.02106, 0.02983, 0.03891, 0.04806, 0.05736, 0.06659, 0.07576, 0.08457, 0.09321, 0.10137, 0.10903, 0.11623, 0.12258, 0.12856, 0.13340, 0.13773, 0.14135, 0.14417, 0.14664, 0.14816, 0.14925, 0.14970, 0.14941, 0.14880, 0.14743, 0.14588, 0.14396, 0.14175, 0.13939, 0.13673, 0.13397, 0.13111, 0.12825, 0.12539, 0.12253, 0.11962, 0.11654, 0.11338, 0.11016, 0.10691, 0.10367, 0.10042, 0.09722, 0.09402, 0.09086, 0.08771, 0.08462, 0.08156, 0.07854, 0.07557, 0.07260, 0.06953, 0.06649, 0.06343, 0.06047, 0.05755, 0.05480, 0.05212, 0.04953, 0.04698, 0.04445, 0.04205, 0.03967, 0.03743, 0.03522, 0.03302, 0.03080, 0.02859, 0.02641, 0.02428, 0.02218, 0.02023, 0.01830, 0.01633, 0.01440, 0.01246, 0.01057, 0.00868, 0.00678, 0.00487, 0.00295, 0.00104, -0.00087, -0.00278, -0.00463, -0.00643, -0.00819, -0.00994, -0.01169, -0.01344, -0.01520, -0.01695, -0.01870, -0.02044, -0.02218, -0.02386, -0.02555, -0.02726, -0.02894, -0.03059, -0.03220, -0.03381, -0.03542, -0.03712, -0.03884, -0.04062, -0.04239, -0.04416, -0.04591, -0.04768, -0.04949, -0.05130, -0.05311, -0.05491, -0.05672, -0.05858, -0.06046, -0.06235, -0.06433, -0.06633, -0.06843, -0.07053, -0.07263, -0.07468, -0.07672, -0.07883, -0.08095, -0.08303, -0.08511, -0.08719, -0.08922, -0.09124, -0.09325, -0.09531, -0.09739, -0.09941, -0.10139, -0.10329, -0.10510, -0.10688, -0.10861, -0.11033, -0.11203, -0.11368, -0.11531, -0.11688, -0.11842, -0.11990, -0.12133, -0.12272, -0.12397, -0.12513, -0.12602, -0.12678, -0.12741, -0.12787, -0.12825, -0.12836, -0.12826, -0.12787, -0.12701, -0.12594, -0.12414, -0.12199, -0.11930, -0.11578, -0.11189, -0.10685, -0.10147, -0.09532, -0.08864, -0.08165, -0.07391, -0.06594, -0.05747, -0.04869, -0.03973, -0.03057, -0.02139, -0.01208, -0.00306, 0.00584, 0.01429, 0.02252, 0.03015, 0.03731, 0.04407, 0.04997, 0.05555, 0.06024, 0.06448, 0.06813, 0.07099, 0.07354, 0.07529, 0.07663, 0.07742, 0.07759, 0.07750, 0.07673, 0.07573, 0.07435, 0.07251, 0.07047, 0.06786, 0.06510, 0.06206, 0.05889, 0.05564, 0.05225, 0.04879, 0.04514, 0.04147, 0.03776, 0.03403, 0.03031, 0.02662, 0.02286, 0.01904, 0.01519, 0.01135, 0.00757, 0.00386, 0.00031, -0.00309, -0.00646, -0.00979, -0.01308, -0.01633, -0.01952, -0.02268, -0.02575, -0.02883, -0.03198, -0.03509, -0.03818, -0.04115, -0.04403, -0.04674, -0.04935, -0.05190, -0.05435, -0.05676, -0.05909, -0.06123, -0.06327, -0.06498, -0.06657, -0.06794, -0.06904, -0.06998, -0.07033, -0.07048, -0.07014, -0.06950, -0.06865, -0.06711, -0.06528, -0.06262, -0.05930, -0.05536, -0.05030, -0.04483, -0.03824, -0.03107, -0.02311, -0.01437, -0.00530])
Epiano_mda_autopan = np.round_(interpolate(Epiano_mda_autopan_raw))

piano_mda_onhit_raw = np.array([0.00165, 0.00882, 0.01563, 0.02182, 0.02673, 0.02982, 0.03128, 0.03113, 0.02963, 0.02728, 0.02417, 0.02087, 0.01767, 0.01468, 0.01218, 0.01041, 0.00964, 0.01035, 0.01230, 0.01526, 0.01926, 0.02328, 0.02682, 0.02985, 0.03244, 0.03473, 0.03644, 0.03748, 0.03763, 0.03622, 0.03326, 0.03018, 0.02795, 0.02689, 0.02802, 0.03134, 0.03595, 0.04123, 0.04657, 0.05090, 0.05411, 0.05536, 0.05423, 0.05176, 0.04831, 0.04431, 0.04013, 0.03607, 0.03244, 0.02963, 0.02780, 0.02744, 0.02872, 0.03101, 0.03409, 0.03751, 0.04050, 0.04300, 0.04456, 0.04501, 0.04462, 0.04333, 0.04147, 0.03979, 0.03857, 0.03781, 0.03735, 0.03702, 0.03610, 0.03430, 0.03253, 0.03152, 0.03122, 0.03220, 0.03439, 0.03665, 0.03824, 0.03903, 0.03857, 0.03687, 0.03418, 0.03049, 0.02634, 0.02185, 0.01743, 0.01364, 0.01096, 0.00894, 0.00723, 0.00568, 0.00385, 0.00146, -0.00110, -0.00375, -0.00677, -0.01019, -0.01392, -0.01801, -0.02228, -0.02655, -0.03076, -0.03470, -0.03815, -0.04083, -0.04269, -0.04330, -0.04291, -0.04166, -0.03973, -0.03754, -0.03546, -0.03375, -0.03333, -0.03458, -0.03790, -0.04382, -0.05176, -0.06076, -0.07034, -0.07852, -0.08374, -0.08603, -0.08401, -0.07819, -0.06967, -0.05930, -0.04849, -0.03873, -0.03027, -0.02466, -0.02252, -0.02304, -0.02637, -0.03165, -0.03726, -0.04251, -0.04706, -0.05048, -0.05301, -0.05502, -0.05664, -0.05817, -0.05960, -0.06094, -0.06168, -0.06186, -0.06125, -0.05960, -0.05762, -0.05569, -0.05405, -0.05246, -0.05078, -0.04871, -0.04578, -0.04214, -0.03821, -0.03412, -0.02942, -0.02371, -0.01712, -0.00958, -0.00131])
piano_mda_onhit = np.round(normalize(interpolate(piano_mda_onhit_raw, 1.004)))
piano_mda_afterhit_raw = np.array([0.00061, 0.00159, 0.00250, 0.00333, 0.00421, 0.00516, 0.00616, 0.00717, 0.00824, 0.00934, 0.01035, 0.01123, 0.01199, 0.01273, 0.01337, 0.01404, 0.01486, 0.01575, 0.01675, 0.01794, 0.01917, 0.02045, 0.02176, 0.02301, 0.02429, 0.02551, 0.02667, 0.02786, 0.02896, 0.03009, 0.03104, 0.03195, 0.03275, 0.03336, 0.03397, 0.03448, 0.03506, 0.03571, 0.03647, 0.03735, 0.03821, 0.03912, 0.03992, 0.04065, 0.04123, 0.04153, 0.04169, 0.04153, 0.04120, 0.04065, 0.03995, 0.03906, 0.03821, 0.03735, 0.03662, 0.03613, 0.03586, 0.03574, 0.03583, 0.03595, 0.03610, 0.03619, 0.03607, 0.03580, 0.03540, 0.03485, 0.03415, 0.03342, 0.03265, 0.03189, 0.03104, 0.03021, 0.02939, 0.02853, 0.02765, 0.02679, 0.02585, 0.02493, 0.02386, 0.02271, 0.02145, 0.01990, 0.01819, 0.01620, 0.01404, 0.01184, 0.00949, 0.00723, 0.00497, 0.00293, 0.00095, -0.00079, -0.00250, -0.00406, -0.00558, -0.00714, -0.00864, -0.01022, -0.01181, -0.01358, -0.01535, -0.01724, -0.01926, -0.02127, -0.02325, -0.02524, -0.02698, -0.02863, -0.03006, -0.03131, -0.03244, -0.03348, -0.03448, -0.03555, -0.03674, -0.03793, -0.03928, -0.04071, -0.04211, -0.04358, -0.04501, -0.04633, -0.04764, -0.04880, -0.04990, -0.05090, -0.05176, -0.05243, -0.05292, -0.05325, -0.05328, -0.05307, -0.05267, -0.05209, -0.05142, -0.05075, -0.05005, -0.04944, -0.04886, -0.04825, -0.04767, -0.04700, -0.04614, -0.04507, -0.04370, -0.04205, -0.04004, -0.03778, -0.03519, -0.03238, -0.02942, -0.02640, -0.02332, -0.02029, -0.01740, -0.01474, -0.01233, -0.01013, -0.00827, -0.00653, -0.00500, -0.00354, -0.00220, -0.00082])
piano_mda_afterhit = np.round(normalize(interpolate(piano_mda_afterhit_raw, 1.0000, True)))

def general_triangle(i, length, peak):
    i = i%length
    if(i < peak):
        return(i/peak*255-128)
    else:
        return((peak-i)/(length-peak)*255+127)
def saw(i, length):
    return general_triangle(i+length/4, length, 0)
def triangle(i, length):
    return general_triangle(i+length/4, length, length/2)

def sine(i, length):
    return 127.5*np.sin(i/length*2*np.pi)-0.5
def square(i, length):
    #i = (i+length/4) %length
    if i < length/2:
        return 127
    else:
        return -128


filename = 'wavetable_output.txt'

with open(filename, 'w') as f:

    
    if(False): #Attack and Decay
        f.write('\n')
        for i in range(128):
            f.write("\t{},\t//{}\n".format(i*2+1, i))
        f.write("\n");
        for i in range(128):
            f.write("\t{},\t//{}\n".format(254-i*2, 128+i))

            
    elif(True): #waveform mix
        f.write("{\n")
        length = 256
        flavours = 16
        output_array = np.zeros((flavours, length))
        for j in range(flavours):
            f.write(" { ")
            for i in range(length):
                factor_a = (j/(flavours-1))
                factor_b = 1-factor_a
                #output_array[j, i] = round(factor_a*saw(i, length) + factor_b*square(i, length)) #Saw and Square
                #output_array[j, i] = round(general_triangle(i+length/4*factor_a, length, length/2*factor_a)) #Saw and Triangle   
                #output_array[j, i] = round(factor_a*sine(i, length) + factor_b*triangle(i, length)) #Sine and Triangle
                #output_array[j, i] = round(factor_a*sine(i, length) + factor_b*square(i, length)) #Sine and Square
                
                output_array[j, i] = round(factor_a*piano_mda_onhit[i] + factor_b*piano_mda_afterhit[i]) #Piano mda
                
                f.write("{:.0f},".format(output_array[j, i]))
                if(i%32 == -1%32):
                    f.write("\n   ")
            f.write("},\n")
            plt.plot(range(length*2), np.tile(output_array[j], 2), label=str(j), alpha =factor_a**2 + factor_b**2)
        f.write("};")
    
    elif(False): #sample
        sample = Epiano_mda_autopan
        length = len(sample)
        f.write('{\n')
        for i in range(length):
            f.write("\t{},\t//{}\n".format(sample[i], i))
        f.write("\n}");
        plt.scatter(range(length*2), np.tile(sample, 2))
print("Saved file as: {}".format(filename))

plt.fill_between(range(length*2), -128, 127, alpha = 0.2)
plt.grid()
plt.show()
